/*
An Easy Problem

출처: http://poj.org/problem?id=2453

아시다시피, 데이터는 컴퓨터에 이진수 형태로 저장됩니다. 우리가 토론할 문제는 양의 정수와 이 수의 이진 형태입니다.

양의 정수 I가 주어지면, 당신이 할 일은 I보다 큰 수 중 가장 작은 수 J를 찾습니다. I의 이진수 형태에서의 1의 개수와 J의 이진수 형태에서의 1의 개수는 일치합니다.

예를들어, "78"이 주어지면, 여러분은 "1001110"과 같은 이진수 형태로 쓸 수 있습니다. 이 이진수는 4개의 1을 가지고 있습니다. "1001110" 보다 크고 4개의 1을 포함하는 가장 작은 정수는 "1010011"입니다. 출력값은 "83"이 되어야 합니다.

Input

각 줄에 한개의 정수를 입력할 수 있습니다. (1 <= I <= 1000000)
0이 나오면 입력을 종료합니다. 이 줄은 작업할 필요 없습니다.

Output

각 줄에 한개의 정수를 출력하면 됩니다.

Sample Input

1
2
3
4
78
0
Sample Output

2
4
5
8
83
*/

/*
아이디어

정규식으로 풀어보았습니다.

일단 xxxxxx01111100000 이런식의 이진수일 때,

- 오른쪽 끝에 있는 제일 첫번째 1을 왼쪽으로 한 칸 옮기고
- 나머지 1들을 오른쪽으로 쉬프트해야 됩니다.

이것을 정규식으로 풀기 위해 다음과 같이 해봤습니다.

고려해야 할 것은 111110000 과 같이 자릿수가 하나 더 늘어나야 하는 경우입니다.
그래서 제일 높은자리 왼쪽에 먼저 0으로 채워놓고 시작합니다. (111110000 -> 0111110000)

1. 2진수의 제일 왼쪽에 0을 추가해줍니다. 그러면 0111, 0100100 등으로 되겠지요.
2. 정규식으로 01(1*)(0*)$ 를 검사합니다. (제일 마지막에 등장하는 0111110000 에 매칭됨)
3. 첫번째의 01 은 10으로 바뀌면 됩니다 (1번에서 0을 추가했기 때문에 1, 111, 의 경우도 커버가 됩니다. 01, 0111 등으로 변해있기 때문)
4. (1*)와 (0*)의 자리를 바꾸어 줍니다.
5. 3, 4에서 한 것이 첫번째 1은 왼쪽으로 한 칸, 나머지 1들은 오른쪽으로 다 미는 것이지요.
6. 다시 10진수로 바꿀 때 제일 첫 자리의 0은 무시됩니다

끝.
*/

var input= `1
            2
            3
            4
            78
            0`;

var easy = function(input) {
    var inputs = input.split("\n").map(v => parseInt(v)),
        results = [],
        n = 0;
    for (let i = 0; n = inputs[i]; i++) {
        results.push(getNext(n));
    }
    return results;
};

var getNext = function(n) {
    return parseInt(("0" + n.toString(2)).replace(/01(1*)(0*)$/g, "10$2$1"), 2);
};

console.log(easy(input).join("\n"));
